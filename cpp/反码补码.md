[code](vscode://file/C:\Users\Wang\Desktop\cpp\Note\6二进制数字系统.cpp)
# 📝 补码 (Two's Complement) 深度学习笔记

## 1. 核心现象：循环性 (Circularity)

计算机的数值空间不是直线，而是一个**圆环**。

- **模运算基础**：$n$ 位系统对应的模为 $M = 2^n$。所有运算都在 $\pmod{2^n}$ 下进行。
    
- **溢出 (Overflow)**：当数值超过最大正数时，会直接“跨过断层”跳到最小负数。
    
    - _例子（8位系统）_：$127 (01111111) + 1 = -128 (10000000)$
        

---

## 2. 向量模型：负权重 (Negative Weight)

补码将最高位 (MSB) 定义为具有**负权重**的向量，这使得符号位能直接参与加法运算。

**真值还原公式：**

$$x = -d_{n-1} \cdot 2^{n-1} + \sum_{i=0}^{n-2} d_i \cdot 2^i$$

- **MSB ($d_{n-1}$)**：不只是符号，它是一个向左跳跃的巨大矢量，权重为 $-2^{n-1}$。
    
- **其余位**：向右跳跃的小矢量。
    
- **-1 的本质**：向左跳最远，再向右跳满（例如 4 位：$-8 + 7 = -1$）。
    

---

## 3. 计算口诀与数学证明

- **口诀**：负数补码 = 反码 (NOT) + 1。
    
- **数学证明**：
    
    $$\text{NOT}(x) = (2^n - 1) - x$$
    
    $$\text{NOT}(x) + 1 = 2^n - x \equiv -x \pmod{2^n}$$
    
    > **结论**：求补码的过程，本质是在模系统里寻找一个“补数”，使得 $x + [x]_{\text{补}} = \text{溢出归零}$。
    

---

## 4. 进阶特性 (维基百科补充)

### A. 符号扩展 (Sign Extension)

当数据从低位数转高位数（如 `char` 转 `int`）时：

- **规则**：高位全部填充原符号位的值。
    
- **目的**：保持向量公式计算出的真值不变。
    

### B. 算术右移 (Arithmetic Shift)

- **操作**：`>>` 运算。
    
- **特性**：右移时左侧补符号位。
    
- **数学意义**：在补码系统下实现“恒等于除以 2”的快速计算。
    

### C. 绝对值陷阱 (The TValue Trap)

- **特殊值**：最小负数（如 8 位中的 `-128`，即 `10000000`）。
    
- **风险**：对该值取绝对值或求负数，结果仍为它本身（因 $128$ 超出了 8 位正数表示范围）。
    
- **代码注意**：`abs(INT_MIN)` 在 C++ 中是未定义行为或溢出。
    

---

## 5. 为什么统治世界？ (Design Philosophy)

1. **零的唯一性**：$[0]_{\text{补}} = 00000000$，消除原码中“正负零”的歧义。
    
2. **硬件极简**：不需要减法器，全靠加法器 + 溢出丢弃。
    
3. **逻辑一致**：不论正负，统一处理。